defmodule Elementary.Lang.App do
  @moduledoc false

  use Elementary.Provider,
    kind: "app",
    module: __MODULE__

  alias Elementary.{Ast, Kit}
  alias Elementary.Lang.{Module, Update}

  defstruct rank: :high,
            name: "",
            version: "1",
            modules: []

  def parse(
        %{
          "version" => version,
          "name" => name,
          "spec" => %{
            "modules" => modules
          }
        },
        _
      ) do
    {:ok,
     %__MODULE__{
       name: name,
       version: version,
       modules: modules
     }}
  end

  def parse(spec, _), do: Kit.error(:not_supported, spec)

  def ast(app, asts) do
    mod_names = app.modules |> Enum.map(&Module.module_name(&1))
    mod_asts = asts |> Ast.filter({:module, mod_names})

    asts = [
      {:module, [app.name, "app"] |> Elementary.Kit.camelize(),
       [
         {:fun, :name, [], {:symbol, app.name}},
         {:fun, :modules, [],
          app.modules
          |> Enum.map(fn m ->
            {:symbol, m}
          end)},
         mod_asts |> init_ast()
       ] ++
         (mod_asts |> update_ast())},
      {:module, [app.name, "state", "machine"] |> Elementary.Kit.camelize(),
       [
         {:usage, Elementary.StateMachine,
          [
            name: app.name
          ]}
       ]}
    ]

    asts
  end

  # Here we merge the contributions from all the
  # modules on the intial model and commands to be
  # generated by this app
  defp init_ast(mods) do
    {model, cmds} =
      mods
      # Retrieve all init functions
      # from all modules
      |> Enum.flat_map(fn ast ->
        ast
        |> Ast.filter({:fun, :init})
      end)
      # For each init function, extract
      # its model and commands, and aggregate them
      # into a single, merged model and commands
      # tuple
      |> Enum.reduce_while({[], []}, fn
        {:fun, :init, [], {:props, [model: {:map, model0}, cmds: cmds0]}}, {model, cmds} ->
          {:cont, {model0 ++ model, cmds0 ++ cmds}}
      end)

    # Build the final ast for the application
    # init function
    {:fun, :init, [], {:props, [model: {:map, model}, cmds: cmds]}}
  end

  # Here we merge the contributions from all the
  # modules on the intial model and commands to be
  # generated by this app
  defp update_ast(mods) do
    # We append a default catch-all
    # clause that reports a not_implemented
    # error
    (mods
     # Retrieve all update functions
     # from all modules. For each module
     # we want to remove the default clause.
     |> Enum.flat_map(fn ast ->
       ast
       |> Ast.filter({:fun, :update})
       |> Enum.drop(-1)
     end)) ++
      [
        Update.not_implemented_ast()
      ]
  end
end
